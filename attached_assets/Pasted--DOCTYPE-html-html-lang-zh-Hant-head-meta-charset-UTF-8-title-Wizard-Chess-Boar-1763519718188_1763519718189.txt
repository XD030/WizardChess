<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>Wizard Chess Board</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #eee;
      font-family: system-ui, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    #layout {
      display: flex;
      gap: 24px;
      align-items: center;
    }

    #left-panel, #right-panel {
      width: 260px;
      font-size: 14px;
    }

    #left-panel h2, #right-panel h2 {
      margin: 0 0 6px;
      font-size: 16px;
    }

    #left-panel .section-title {
      margin-top: 8px;
      font-weight: 600;
      font-size: 13px;
    }

    #left-panel ul {
      margin: 4px 0 0 18px;
      padding: 0;
    }

    #left-panel li {
      margin-bottom: 2px;
    }

    #piece-name {
      font-weight: 700;
      margin-bottom: 2px;
    }

    #board-container {
      text-align: center;
      position: relative;
    }

    canvas {
      background: #000;
      border-radius: 8px;
    }

    .turn {
      font-size: 16px;
      margin-bottom: 8px;
    }
    .dot {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin: 0 4px;
      vertical-align: middle;
      border: 1px solid #fff;
    }
    .dot.white { background:#fff; }
    .dot.black { background:#000; }

    .hint {
      margin-top: 4px;
      font-size: 12px;
      opacity: 0.8;
    }

    #history {
      margin-top: 8px;
      font-size: 12px;
      border-top: 1px solid #555;
      padding-top: 6px;
      max-height: 260px;
      overflow-y: auto;
      white-space: pre-line;
    }
    #history-line {
      font-weight: 600;
      margin-bottom: 2px;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div id="layout">
    <!-- å·¦å´ï¼šæ£‹å­è³‡è¨Š -->
    <div id="left-panel">
      <h2>æ£‹å­è³‡è¨Š</h2>
      <div id="piece-name">æœªé¸å–æ£‹å­</div>
      <div id="piece-side"></div>

      <div class="section-title">ç§»å‹•æ–¹å¼</div>
      <ul id="move-desc">
        <li>é»æ“Šè‡ªå·±çš„å·«å¸«å¯ä»¥æŸ¥çœ‹èƒ½åŠ›ã€‚</li>
      </ul>

      <div class="section-title">èƒ½åŠ›</div>
      <ul id="ability-desc">
        <li>ç›®å‰åªå¯¦ä½œå·«å¸«çš„å®Œæ•´èƒ½åŠ›ã€‚</li>
      </ul>
    </div>

    <!-- ä¸­é–“ï¼šæ£‹ç›¤ -->
    <div id="board-container">
      <canvas id="board"></canvas>
      <div class="hint" id="hint"></div>
    </div>

    <!-- å³å´ï¼šå›åˆ + æ­·å² -->
    <div id="right-panel">
      <h2>å›åˆè³‡è¨Š</h2>
      <div id="turn" class="turn"></div>

      <div id="history-line">ç§»å‹•ç´€éŒ„</div>
      <div id="history">(å°šç„¡ç§»å‹•)</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const hintEl = document.getElementById('hint');
    const turnEl = document.getElementById('turn');
    const historyEl = document.getElementById('history');

    const pieceNameEl = document.getElementById('piece-name');
    const pieceSideEl = document.getElementById('piece-side');
    const moveDescEl = document.getElementById('move-desc');
    const abilityDescEl = document.getElementById('ability-desc');

    // ===== ç‰ˆé¢å¤§å° / HiDPI =====
    const LOGICAL_SIZE = 700;
    let W = LOGICAL_SIZE;
    let H = LOGICAL_SIZE;
    let CX = W / 2;
    let CY = H / 2;

    function setupCanvas() {
      const ratio = window.devicePixelRatio || 1;

      canvas.style.width = LOGICAL_SIZE + 'px';
      canvas.style.height = LOGICAL_SIZE + 'px';
      canvas.width = LOGICAL_SIZE * ratio;
      canvas.height = LOGICAL_SIZE * ratio;

      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

      W = LOGICAL_SIZE;
      H = LOGICAL_SIZE;
      CX = W / 2;
      CY = H / 2;
    }

    // ===== æ£‹ç›¤å¹¾ä½• =====
    const N = 8;
    const STEP = 40;
    const VSTEP = STEP * 0.5;
    const NODE_RADIUS = 4;

    const rows = [];
    const allNodes = [];
    const rcToIndex = {};
    let adjacency = [];

    function buildRows() {
      rows.length = 0;
      for (let i = 0; i <= 2 * N; i++) {
        const level = i;
        const count = (level <= N) ? (level + 1) : (2 * N + 1 - level);
        const y = (level - N) * VSTEP;
        const xStart = -(count - 1) * STEP / 2;

        const row = [];
        for (let j = 0; j < count; j++) {
          const x = xStart + j * STEP;
          row.push({ x: CX + x, y: CY + y });
        }
        rows.push(row);
      }
    }

    function buildAllNodes() {
      allNodes.length = 0;
      for (let ri = 0; ri < rows.length; ri++) {
        for (let ci = 0; ci < rows[ri].length; ci++) {
          const p = rows[ri][ci];
          const idx = allNodes.length;
          allNodes.push({ x: p.x, y: p.y, row: ri, col: ci });
          rcToIndex[`${ri},${ci}`] = idx;
        }
      }
    }

    function connectAdj(adj, r1, c1, r2, c2) {
      const i1 = rcToIndex[`${r1},${c1}`];
      const i2 = rcToIndex[`${r2},${c2}`];
      if (i1 === undefined || i2 === undefined) return;
      adj[i1].push(i2);
      adj[i2].push(i1);
    }

    function buildAdjacency() {
      adjacency = new Array(allNodes.length);
      for (let i = 0; i < adjacency.length; i++) adjacency[i] = [];

      // åŒåˆ—
      for (let r = 0; r < rows.length; r++) {
        const row = rows[r];
        for (let c = 0; c < row.length - 1; c++) {
          connectAdj(adjacency, r, c, r, c + 1);
        }
      }

      // ä¸Šä¸‹åˆ—
      for (let r = 0; r < rows.length - 1; r++) {
        const rowA = rows[r];
        const rowB = rows[r + 1];

        if (rowB.length === rowA.length + 1) {
          for (let c = 0; c < rowA.length; c++) {
            connectAdj(adjacency, r, c, r + 1, c);
            connectAdj(adjacency, r, c, r + 1, c + 1);
          }
        } else if (rowA.length === rowB.length + 1) {
          for (let c = 0; c < rowB.length; c++) {
            connectAdj(adjacency, r + 1, c, r, c);
            connectAdj(adjacency, r + 1, c, r, c + 1);
          }
        }
      }
    }

    function getNodePosition(rowIndex, colIndex) {
      const r = rows[rowIndex];
      if (!r || !r[colIndex]) return null;
      return r[colIndex];
    }

    // ===== æ£‹å­è³‡æ–™ =====
    const whiteBasePieces = [
      { type: 'wizard', row: 16, col: 0 },  // å·«å¸«
      { type: 'dragon', row: 14, col: 1 },

      { type: 'ranger',  row: 13, col: 0 },
      { type: 'ranger',  row: 13, col: 3 },
      { type: 'paladin', row: 13, col: 1 },
      { type: 'paladin', row: 13, col: 2 },
      { type: 'assassin', row: 12, col: 1 },
      { type: 'assassin', row: 12, col: 3 },

      // 7 å€‹å­¸å¾’ï¼ˆrow = 10ï¼‰
      { type: 'apprentice', row: 10, col: 0 },
      { type: 'apprentice', row: 10, col: 1 },
      { type: 'apprentice', row: 10, col: 2 },
      { type: 'apprentice', row: 10, col: 3 },
      { type: 'apprentice', row: 10, col: 4 },
      { type: 'apprentice', row: 10, col: 5 },
      { type: 'apprentice', row: 10, col: 6 },
    ];

    const pieces = [];

    function buildPieces() {
      pieces.length = 0;

      // ç™½æ–¹
      for (const p of whiteBasePieces) {
        pieces.push({
          type: p.type,
          side: 'white',
          row: p.row,
          col: p.col,
        });
      }

      // é»‘æ–¹ï¼ˆrow å°ç¨±ï¼‰
      for (const p of whiteBasePieces) {
        pieces.push({
          type: p.type,
          side: 'black',
          row: 2 * N - p.row,
          col: p.col,
        });
      }

      // åŸéŠè©©äººï¼ˆä¸­å¿ƒï¼‰
      pieces.push({
        type: 'bard',
        side: 'neutral',
        row: 8,
        col: 4,
      });
    }

    function pieceEmoji(type) {
      switch (type) {
        case 'wizard': return 'ğŸ§™â€â™‚ï¸';
        case 'apprentice': return 'ğŸ§';
        case 'dragon': return 'ğŸ‰';
        case 'ranger': return 'ğŸ¹';
        case 'paladin': return 'ğŸ›¡ï¸';
        case 'assassin': return 'ğŸ—¡ï¸';
        case 'bard': return 'ğŸµ';
        default: return '?';
      }
    }

    function getPieceAt(row, col) {
      for (let i = 0; i < pieces.length; i++) {
        const p = pieces[i];
        if (p.row === row && p.col === col) return i;
      }
      return -1;
    }

    // ===== åç¨± / æè¿° =====
    const sideNames = {
      white: 'ç™½æ–¹',
      black: 'é»‘æ–¹',
      neutral: 'ä¸­ç«‹'
    };

    const typeChinese = {
      wizard: 'å·«å¸«',
      apprentice: 'å­¸å¾’',
      dragon: 'é¾',
      ranger: 'éŠä¿ ',
      paladin: 'è–é¨å£«',
      assassin: 'åˆºå®¢',
      bard: 'åŸéŠè©©äºº'
    };

    const pieceDescriptions = {
      wizard: {
        name: 'ã€Šå·«å¸«ã€‹',
        move: [
          'æ²¿ç¯€é»é€£ç·šç§»å‹• 1 ç¯€é»ã€‚'
        ],
        ability: [
          'å°ç·šæ˜¯æŒ‡èƒ½è·Ÿå¦ä¸€æ£‹å­é€£çµä¸”ä¸­é–“ç„¡å…¶ä»–ç¯€é»ï¼Œå¯è½‰æ›æ–¹å‘ã€‚',
          'å¯é€éå·±æ–¹å­¸å¾’æˆ–åŸéŠè©©äººå»ºç«‹å°ç·šï¼Œè‹¥å°ç·šèƒ½é€£æ¥è‡³æ•µæ–¹æ£‹å­ï¼Œå³å¯æ“Šæ®ºè©²æ£‹å­ï¼Œè·é›¢ä¸é™ï¼Œé‡ç¬¬ä¸€å€‹æ•µæ–¹æ£‹å­ç‚ºæ­¢ã€‚',
          'å¯èˆ‡ä»»æ„å·±æ–¹å­¸å¾’ç„¡è·é›¢æ›ä½ã€‚'
        ]
      },
      apprentice: {
        name: 'ã€Šå­¸å¾’ã€‹',
        move: ['ï¼ˆå°šæœªå¯¦ä½œå®Œæ•´è¦å‰‡ï¼‰'],
        ability: ['å¯ä½œç‚ºå·«å¸«å°ç·šçš„å°é«”ã€‚']
      },
      dragon: {
        name: 'ã€Šé¾ã€‹',
        move: ['æ²¿ç›´ç·šå‰é€²ï¼Œè·é›¢ä¸é™ï¼ˆä¹‹å¾Œè£œä¸Šç¼ç—•æ•ˆæœï¼‰ã€‚'],
        ability: ['ï¼ˆä¹‹å¾Œè£œå®Œï¼‰']
      },
      ranger: {
        name: 'ã€ŠéŠä¿ ã€‹',
        move: ['è·³æ£‹å¼ç§»å‹•æˆ– 1 ç¯€é»ç§»å‹•ï¼ˆä¹‹å¾Œè£œå®Œï¼‰ã€‚'],
        ability: ['è½é»è‹¥æœ‰æ•µäººå‰‡æ“Šæ®ºã€‚']
      },
      paladin: {
        name: 'ã€Šè–é¨å£«ã€‹',
        move: ['æ²¿ç¯€é»é€£ç·šç§»å‹• 1 ç¯€é»ï¼ˆä¹‹å¾Œè£œå®Œï¼‰'],
        ability: ['å®ˆè­·èˆ‡è–å…‰æ•ˆæœå°‡ä¹‹å¾ŒåŠ å…¥ã€‚']
      },
      assassin: {
        name: 'ã€Šåˆºå®¢ã€‹',
        move: ['æ²¿å¹³è¡Œå››é‚Šå½¢å°è§’ç§»å‹•ï¼ˆä¹‹å¾Œè£œå®Œï¼‰ã€‚'],
        ability: ['æ½›è¡Œèˆ‡é¡¯å½¢æ©Ÿåˆ¶ä¹‹å¾ŒåŠ å…¥ã€‚']
      },
      bard: {
        name: 'ã€ŠåŸéŠè©©äººã€‹',
        move: ['ç„¡æ³•ä¸»å‹•ç§»å‹•ï¼Œåªèƒ½æ›ä½ï¼ˆä¹‹å¾Œè£œå®Œï¼‰ã€‚'],
        ability: ['å¯ä½œç‚ºå·«å¸«å°ç·šçš„ä¸€éƒ¨åˆ†ã€‚']
      }
    };

    function renderPieceInfo(piece) {
      if (!piece) {
        pieceNameEl.textContent = 'æœªé¸å–æ£‹å­';
        pieceSideEl.textContent = '';
        moveDescEl.innerHTML = '<li>é»æ“Šè‡ªå·±çš„å·«å¸«å¯ä»¥æŸ¥çœ‹èƒ½åŠ›ã€‚</li>';
        abilityDescEl.innerHTML = '<li>ç›®å‰åªå¯¦ä½œå·«å¸«çš„å®Œæ•´è¡Œå‹•ã€‚</li>';
        return;
      }
      const desc = pieceDescriptions[piece.type] || null;
      pieceNameEl.textContent =
        (desc ? desc.name : 'ã€ŠæœªçŸ¥æ£‹å­ã€‹') + 'ã€€' + (typeChinese[piece.type] || '');
      pieceSideEl.textContent = 'é™£ç‡Ÿï¼š' + (sideNames[piece.side] || '');

      // ç§»å‹•
      moveDescEl.innerHTML = '';
      const moves = desc ? desc.move : ['æš«ç„¡èªªæ˜'];
      moves.forEach(t => {
        const li = document.createElement('li');
        li.textContent = t;
        moveDescEl.appendChild(li);
      });

      // èƒ½åŠ›
      abilityDescEl.innerHTML = '';
      const ab = desc ? desc.ability : ['æš«ç„¡èªªæ˜'];
      ab.forEach(t => {
        const li = document.createElement('li');
        li.textContent = t;
        abilityDescEl.appendChild(li);
      });
    }

    // ===== å›åˆ & é¸å– & æ­·å² =====
    let currentPlayer = 'white';
    let selectedPieceIndex = -1;
    let legalMoveNodeSet = new Set();
    let legalAttackNodeSet = new Set();
    let swapTargetMap = new Map();
    let gameOver = false;
    const moveHistory = [];

    function coordString(row, col) {
      return `(${row},${col})`;
    }

    function logMove(text) {
      moveHistory.push(text);
      historyEl.textContent = moveHistory
        .map((t, i) => `${i + 1}. ${t}`)
        .join('\n');
    }

    function updateUI() {
      if (currentPlayer === 'white') {
        turnEl.innerHTML = 'ç›®å‰å›åˆï¼š<span class="dot white"></span> ç™½æ–¹';
      } else {
        turnEl.innerHTML = 'ç›®å‰å›åˆï¼š<span class="dot black"></span> é»‘æ–¹';
      }
      hintEl.textContent = 'å·«å¸«ï¼šç¶ =ç§»å‹•ã€é»ƒ=èˆ‡å­¸å¾’æ›ä½ã€ç´…=å°ç·šæ”»æ“Šã€‚';
    }

    // ===== å·«å¸«èƒ½åŠ› =====
    function getWizardStepMoves(piece) {
      const moves = [];
      const startIdx = rcToIndex[`${piece.row},${piece.col}`];
      if (startIdx === undefined) return moves;
      const neighbors = adjacency[startIdx];
      for (const nIdx of neighbors) {
        const node = allNodes[nIdx];
        if (getPieceAt(node.row, node.col) === -1) {
          moves.push(nIdx);
        }
      }
      return moves;
    }

    function getWizardSwapTargets(piece) {
      const targets = [];
      for (let i = 0; i < pieces.length; i++) {
        const p = pieces[i];
        if (p.type === 'apprentice' && p.side === piece.side) {
          const idx = rcToIndex[`${p.row},${p.col}`];
          targets.push({ nodeIndex: idx, pieceIndex: i });
        }
      }
      return targets;
    }

    function getWizardAttackTargets(piece) {
      const targets = new Set();
      const startIdx = rcToIndex[`${piece.row},${piece.col}`];
      const queue = [startIdx];
      const visited = new Set([startIdx]);

      while (queue.length) {
        const cur = queue.shift();
        for (const nIdx of adjacency[cur]) {
          if (visited.has(nIdx)) continue;
          const node = allNodes[nIdx];
          const occIndex = getPieceAt(node.row, node.col);
          if (occIndex === -1) continue;

          const occ = pieces[occIndex];
          const isConductor =
            (occ.type === 'apprentice' && occ.side === piece.side) ||
            (occ.type === 'bard');

          if (isConductor) {
            visited.add(nIdx);
            queue.push(nIdx);
          } else if (occ.side !== piece.side) {
            targets.add(nIdx);
          }
        }
      }
      return targets;
    }

    function selectPiece(pieceIndex) {
      selectedPieceIndex = pieceIndex;
      const p = pieces[pieceIndex];

      legalMoveNodeSet.clear();
      legalAttackNodeSet.clear();
      swapTargetMap.clear();

      if (p.type === 'wizard') {
        const stepMoves = getWizardStepMoves(p);
        stepMoves.forEach(n => legalMoveNodeSet.add(n));

        const swapTargets = getWizardSwapTargets(p);
        swapTargets.forEach(t => {
          legalMoveNodeSet.add(t.nodeIndex);
          swapTargetMap.set(t.nodeIndex, t.pieceIndex);
        });

        const attackTargets = getWizardAttackTargets(p);
        attackTargets.forEach(t => legalAttackNodeSet.add(t));
      }

      renderPieceInfo(p);
    }

    function clearSelection() {
      selectedPieceIndex = -1;
      legalMoveNodeSet.clear();
      legalAttackNodeSet.clear();
      swapTargetMap.clear();
      renderPieceInfo(null);
    }

    // ===== ç¹ªè£½ =====
    function drawTriangle(p1, p2, p3, fillColor) {
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();
      ctx.strokeStyle = '#ffffff20';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    function drawPieces() {
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for (const p of pieces) {
        const pos = getNodePosition(p.row, p.col);
        if (!pos) continue;

        ctx.beginPath();
        ctx.arc(pos.x, pos.y - 2, 12, 0, Math.PI * 2);
        if (p.side === 'white') ctx.fillStyle = 'rgba(255,255,255,0.9)';
        else if (p.side === 'black') ctx.fillStyle = 'rgba(20,20,20,0.9)';
        else ctx.fillStyle = 'rgba(80,150,255,0.9)';
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.font = '18px system-ui, emoji';
        ctx.fillText(pieceEmoji(p.type), pos.x, pos.y - 2);
      }
    }

    function drawCoordinates() {
      ctx.fillStyle = '#ffffff';
      ctx.font = '14px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for (let i = 0; i <= 8; i++) {
        const p = rows[i][i];
        const ch = String.fromCharCode(65 + i);
        ctx.fillText(ch, p.x + 14, p.y - 14);
      }

      for (let i = 0; i <= 8; i++) {
        const rowIndex = 8 + i;
        const colIndex = 8 - i;
        const p = rows[rowIndex][colIndex];
        ctx.fillText(String(i + 1), p.x + 14, p.y + 14);
      }
    }

    function drawBoard() {
      ctx.clearRect(0, 0, W, H);

      for (let i = 0; i < rows.length - 1; i++) {
        const rowA = rows[i];
        const rowB = rows[i + 1];

        if (rowB.length === rowA.length + 1) {
          const m = rowA.length;
          for (let j = 0; j < m; j++) {
            drawTriangle(rowA[j], rowB[j], rowB[j + 1], '#ffffff');
          }
          for (let j = 0; j < m - 1; j++) {
            drawTriangle(rowB[j + 1], rowA[j], rowA[j + 1], '#111111');
          }
        } else if (rowA.length === rowB.length + 1) {
          const m = rowB.length;
          for (let j = 0; j < m; j++) {
            drawTriangle(rowB[j], rowA[j], rowA[j + 1], '#111111');
          }
          for (let j = 0; j < m - 1; j++) {
            drawTriangle(rowA[j + 1], rowB[j], rowB[j + 1], '#ffffff');
          }
        }
      }

      for (let idx = 0; idx < allNodes.length; idx++) {
        const p = allNodes[idx];

        if (swapTargetMap.has(idx)) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, NODE_RADIUS + 11, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 255, 0, 0.55)';
          ctx.fill();
        }

        if (legalMoveNodeSet.has(idx)) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, NODE_RADIUS + 5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
          ctx.fill();
        }

        if (legalAttackNodeSet.has(idx)) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, NODE_RADIUS + 7, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 0, 0, 0.45)';
          ctx.fill();
        }

        ctx.beginPath();
        ctx.arc(p.x, p.y, NODE_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = '#3fa9ff';
        ctx.fill();
      }

      drawPieces();
      drawCoordinates();
    }

    // ===== é»æ“Šäº‹ä»¶ =====
    canvas.addEventListener('click', (e) => {
      if (gameOver) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      let bestIndex = -1;
      let bestDist2 = Infinity;
      const CLICK_RADIUS = 20;

      for (let i = 0; i < allNodes.length; i++) {
        const p = allNodes[i];
        const dx = mx - p.x;
        const dy = my - p.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestDist2) {
          bestDist2 = d2;
          bestIndex = i;
        }
      }
      if (bestIndex < 0 || bestDist2 > CLICK_RADIUS * CLICK_RADIUS) return;

      const node = allNodes[bestIndex];
      const pieceIndexAtNode = getPieceAt(node.row, node.col);

      // å·²é¸å–
      if (selectedPieceIndex >= 0) {
        const sel = pieces[selectedPieceIndex];

        // æ”»æ“Š
        if (legalAttackNodeSet.has(bestIndex)) {
          if (
            pieceIndexAtNode !== -1 &&
            pieces[pieceIndexAtNode].side !== sel.side
          ) {
            const killed = pieces[pieceIndexAtNode];
            logMove(`${sideNames[sel.side]} ${typeChinese[sel.type]} ä½¿ç”¨å°ç·šæ“Šæ®º `
              + `${sideNames[killed.side]} ${typeChinese[killed.type]} ${coordString(node.row,node.col)}`);

            pieces.splice(pieceIndexAtNode, 1);

            if (killed.type === 'wizard') {
              gameOver = true;
              drawBoard();
              alert(`${sideNames[sel.side]} ç²å‹ï¼ˆæ“Šæ®ºå·«å¸«ï¼‰ï¼`);
              return;
            }
          }

          clearSelection();
          currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
          updateUI();
          drawBoard();
          return;
        }

        // ç§»å‹• / æ›ä½
        if (legalMoveNodeSet.has(bestIndex)) {
          if (swapTargetMap.has(bestIndex)) {
            const apIndex = swapTargetMap.get(bestIndex);
            const ap = pieces[apIndex];

            const fromWizard = coordString(sel.row, sel.col);
            const fromAp = coordString(ap.row, ap.col);

            // äº¤æ›
            const tmpR = sel.row, tmpC = sel.col;
            sel.row = ap.row; sel.col = ap.col;
            ap.row = tmpR; ap.col = tmpC;

            logMove(`${sideNames[sel.side]} å·«å¸« èˆ‡ å­¸å¾’ æ›ä½ `
              + `${fromWizard} â†” ${fromAp}`);

          } else {
            const from = coordString(sel.row, sel.col);
            sel.row = node.row;
            sel.col = node.col;
            const to = coordString(sel.row, sel.col);
            logMove(`${sideNames[sel.side]} ${typeChinese[sel.type]} ${from} â†’ ${to}`);
          }

          clearSelection();
          currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
          updateUI();
          drawBoard();
          return;
        }

        // é‡æ–°é¸å·«å¸«
        if (pieceIndexAtNode !== -1) {
          const p = pieces[pieceIndexAtNode];
          if (p.type === 'wizard' && p.side === currentPlayer) {
            selectPiece(pieceIndexAtNode);
            drawBoard();
            return;
          }
        }

        clearSelection();
        drawBoard();
        return;
      }

      // æœªé¸å– â†’ åªèƒ½é¸è‡ªå·±çš„å·«å¸«
      if (pieceIndexAtNode !== -1) {
        const p = pieces[pieceIndexAtNode];
        if (p.type === 'wizard' && p.side === currentPlayer) {
          selectPiece(pieceIndexAtNode);
          drawBoard();
          return;
        }
      }

      drawBoard();
    });

    // ===== åˆå§‹åŒ– =====
    function init() {
      setupCanvas();
      buildRows();
      buildAllNodes();
      buildAdjacency();
      buildPieces();
      clearSelection();
      currentPlayer = 'white';
      gameOver = false;
      updateUI();
      drawBoard();
    }

    init();
    window.addEventListener('resize', init);
  </script>
</body>
</html>
